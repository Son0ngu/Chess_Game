{"ast":null,"code":"import { Chess } from 'chess.js';\nimport { BehaviorSubject } from 'rxjs';\nconst chess = new Chess();\n\n// Add history tracking\nconst moveHistory = [];\nconst redoStack = [];\n\n// Update the gameSubject initialization to include moveNotation\nexport const gameSubject = new BehaviorSubject({\n  board: chess.board(),\n  pendingPromotion: null,\n  isGameOver: false,\n  turn: chess.turn(),\n  result: null,\n  canUndo: false,\n  canRedo: false,\n  moveNotation: [] // Add this line\n});\nexport function initGame() {\n  const savedGame = localStorage.getItem('savedGame');\n  if (savedGame) {\n    try {\n      chess.load(savedGame);\n      console.log('Loaded game state:', chess.fen());\n      if (!chess.board()) {\n        throw new Error('Invalid board state after loading FEN');\n      }\n\n      // Initialize history from saved history if available\n      const savedHistory = localStorage.getItem('moveHistory');\n      if (savedHistory) {\n        moveHistory.length = 0;\n        moveHistory.push(...JSON.parse(savedHistory));\n      }\n    } catch (error) {\n      console.error('Failed to load saved game:', error);\n      chess.reset();\n      localStorage.removeItem('savedGame');\n      localStorage.removeItem('moveHistory');\n      moveHistory.length = 0;\n      redoStack.length = 0;\n      console.log('Reset game due to invalid FEN:', chess.fen());\n    }\n  } else {\n    chess.reset();\n    moveHistory.length = 0;\n    redoStack.length = 0;\n    console.log('Started new game:', chess.fen());\n  }\n  updateGame();\n}\nexport function resetGame() {\n  chess.reset();\n  moveHistory.length = 0;\n  redoStack.length = 0;\n  localStorage.removeItem('savedGame');\n  localStorage.removeItem('moveHistory');\n  console.log('Game reset:', chess.fen());\n  updateGame();\n}\nresetGame();\nexport function handleMove(from, to) {\n  console.log(`Handling move from ${from} to ${to}`);\n  console.log('Current turn:', chess.turn());\n  console.log('Current board state:', chess.fen());\n  const promotions = chess.moves({\n    verbose: true\n  }).filter(m => m.promotion);\n  if (promotions.some(p => `${p.from}:${p.to}` === `${from}:${to}`)) {\n    console.log('Promotion detected:', promotions);\n    const pendingPromotion = {\n      from,\n      to,\n      color: promotions[0].color\n    };\n    updateGame(pendingPromotion);\n    return;\n  }\n  const currentGame = gameSubject.getValue();\n  if (!currentGame.pendingPromotion) {\n    move(from, to);\n  }\n}\nexport function move(from, to, promotion) {\n  const moveObj = {\n    from,\n    to,\n    ...(promotion && {\n      promotion\n    })\n  };\n  console.log('Attempting move:', moveObj);\n  try {\n    const legalMove = chess.move(moveObj);\n    if (legalMove) {\n      console.log('Move successful:', chess.fen());\n      // Save position before the move to history\n      moveHistory.push({\n        fen: legalMove.before,\n        move: legalMove\n      });\n      // Clear redo stack after a new move\n      redoStack.length = 0;\n      updateGame();\n    } else {\n      console.error('Move failed:', moveObj);\n    }\n  } catch (error) {\n    console.error('Error during move:', error.message);\n  }\n}\n\n// Add undo function\nexport function undo() {\n  if (moveHistory.length === 0) {\n    console.log('No moves to undo');\n    return;\n  }\n  const lastPosition = moveHistory.pop();\n  redoStack.push({\n    fen: chess.fen(),\n    move: chess.history({\n      verbose: true\n    }).pop()\n  });\n\n  // Load the previous position\n  chess.reset();\n  moveHistory.forEach(({\n    move\n  }) => {\n    chess.move(move);\n  });\n  console.log('Move undone, new state:', chess.fen());\n  updateGame();\n}\n\n// Add redo function\nexport function redo() {\n  if (redoStack.length === 0) {\n    console.log('No moves to redo');\n    return;\n  }\n  const nextPosition = redoStack.pop();\n  moveHistory.push({\n    fen: chess.fen(),\n    move: nextPosition.move\n  });\n\n  // Replay the move that was undone\n  const {\n    from,\n    to,\n    promotion\n  } = nextPosition.move;\n  chess.move({\n    from,\n    to,\n    promotion\n  });\n  console.log('Move redone, new state:', chess.fen());\n  updateGame();\n}\n\n// Update the updateGame function to properly display castling notation\nfunction updateGame(pendingPromotion = null) {\n  const isGameOver = chess.isGameOver();\n\n  // Get standard notation history\n  const standardNotation = chess.history();\n\n  // Get detailed move history with piece information\n  const detailedHistory = chess.history({\n    verbose: true\n  });\n\n  // Create enhanced notation with piece type and castling info\n  const enhancedNotation = standardNotation.map((move, index) => {\n    const detailedMove = detailedHistory[index];\n    if (!detailedMove) return move;\n\n    // Special handling for castling\n    if (move === 'O-O') {\n      return 'King Castles Kingside';\n    } else if (move === 'O-O-O') {\n      return 'King Castles Queenside';\n    }\n\n    // Map piece codes to readable names\n    const pieceNames = {\n      'p': 'Pawn',\n      'n': 'Knight',\n      'b': 'Bishop',\n      'r': 'Rook',\n      'q': 'Queen',\n      'k': 'King'\n    };\n    const pieceName = pieceNames[detailedMove.piece] || 'Unknown';\n\n    // Check if capture happened\n    let moveText = move;\n    if (detailedMove.captured) {\n      const capturedPiece = pieceNames[detailedMove.captured] || 'piece';\n      moveText += ` (captures ${capturedPiece})`;\n    }\n\n    // Check if it's a check or checkmate\n    if (move.includes('+')) {\n      moveText = moveText.replace('+', '') + ' (check)';\n    } else if (move.includes('#')) {\n      moveText = moveText.replace('#', '') + ' (checkmate)';\n    }\n    return `${pieceName} ${moveText}`;\n  });\n  const newGame = {\n    board: chess.board(),\n    pendingPromotion,\n    isGameOver,\n    turn: chess.turn(),\n    result: isGameOver ? getGameResult() : null,\n    canUndo: moveHistory.length > 0,\n    canRedo: redoStack.length > 0,\n    moveNotation: enhancedNotation\n  };\n  localStorage.setItem('savedGame', chess.fen());\n  localStorage.setItem('moveHistory', JSON.stringify(moveHistory));\n  gameSubject.next(newGame);\n}\nfunction getGameResult() {\n  if (chess.isCheckmate()) {\n    const winner = chess.turn() === 'w' ? 'BLACK' : 'WHITE';\n    return `CHECKMATE - WINNER - ${winner}`;\n  } else if (chess.isDraw()) {\n    if (chess.isStalemate()) return 'DRAW - STALEMATE';\n    if (chess.isThreefoldRepetition()) return 'DRAW - REPETITION';\n    if (chess.isInsufficientMaterial()) return 'DRAW - INSUFFICIENT MATERIAL';\n    return 'DRAW - 50 MOVE RULE';\n  }\n  return 'UNKNOWN REASON';\n}","map":{"version":3,"names":["Chess","BehaviorSubject","chess","moveHistory","redoStack","gameSubject","board","pendingPromotion","isGameOver","turn","result","canUndo","canRedo","moveNotation","initGame","savedGame","localStorage","getItem","load","console","log","fen","Error","savedHistory","length","push","JSON","parse","error","reset","removeItem","updateGame","resetGame","handleMove","from","to","promotions","moves","verbose","filter","m","promotion","some","p","color","currentGame","getValue","move","moveObj","legalMove","before","message","undo","lastPosition","pop","history","forEach","redo","nextPosition","standardNotation","detailedHistory","enhancedNotation","map","index","detailedMove","pieceNames","pieceName","piece","moveText","captured","capturedPiece","includes","replace","newGame","getGameResult","setItem","stringify","next","isCheckmate","winner","isDraw","isStalemate","isThreefoldRepetition","isInsufficientMaterial"],"sources":["E:/ƒêH/20242/Secure Web Dev/Project_Chess/Chess_Game/chess_frontend/src/Game.js"],"sourcesContent":["import { Chess } from 'chess.js';\r\nimport { BehaviorSubject } from 'rxjs';\r\n\r\nconst chess = new Chess();\r\n\r\n// Add history tracking\r\nconst moveHistory = [];\r\nconst redoStack = [];\r\n\r\n// Update the gameSubject initialization to include moveNotation\r\nexport const gameSubject = new BehaviorSubject({\r\n  board: chess.board(),\r\n  pendingPromotion: null,\r\n  isGameOver: false,\r\n  turn: chess.turn(),\r\n  result: null,\r\n  canUndo: false,\r\n  canRedo: false,\r\n  moveNotation: [] // Add this line\r\n});\r\n\r\nexport function initGame() {\r\n    const savedGame = localStorage.getItem('savedGame');\r\n    if (savedGame) {\r\n      try {\r\n        chess.load(savedGame);\r\n        console.log('Loaded game state:', chess.fen());\r\n        if (!chess.board()) {\r\n          throw new Error('Invalid board state after loading FEN');\r\n        }\r\n        \r\n        // Initialize history from saved history if available\r\n        const savedHistory = localStorage.getItem('moveHistory');\r\n        if (savedHistory) {\r\n          moveHistory.length = 0;\r\n          moveHistory.push(...JSON.parse(savedHistory));\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to load saved game:', error);\r\n        chess.reset();\r\n        localStorage.removeItem('savedGame');\r\n        localStorage.removeItem('moveHistory');\r\n        moveHistory.length = 0;\r\n        redoStack.length = 0;\r\n        console.log('Reset game due to invalid FEN:', chess.fen());\r\n      }\r\n    } else {\r\n      chess.reset();\r\n      moveHistory.length = 0;\r\n      redoStack.length = 0;\r\n      console.log('Started new game:', chess.fen());\r\n    }\r\n    updateGame();\r\n}\r\n\r\nexport function resetGame() {\r\n  chess.reset();\r\n  moveHistory.length = 0;\r\n  redoStack.length = 0;\r\n  localStorage.removeItem('savedGame');\r\n  localStorage.removeItem('moveHistory');\r\n  console.log('Game reset:', chess.fen());\r\n  updateGame();\r\n}\r\n\r\nresetGame();\r\n\r\nexport function handleMove(from, to) {\r\n  console.log(`Handling move from ${from} to ${to}`);\r\n  console.log('Current turn:', chess.turn());\r\n  console.log('Current board state:', chess.fen());\r\n\r\n  const promotions = chess.moves({ verbose: true }).filter((m) => m.promotion);\r\n  if (promotions.some((p) => `${p.from}:${p.to}` === `${from}:${to}`)) {\r\n    console.log('Promotion detected:', promotions);\r\n    const pendingPromotion = { from, to, color: promotions[0].color };\r\n    updateGame(pendingPromotion);\r\n    return;\r\n  }\r\n\r\n  const currentGame = gameSubject.getValue();\r\n  if (!currentGame.pendingPromotion) {\r\n    move(from, to);\r\n  }\r\n}\r\n\r\nexport function move(from, to, promotion) {\r\n  const moveObj = { from, to, ...(promotion && { promotion }) };\r\n  console.log('Attempting move:', moveObj);\r\n\r\n  try {\r\n    const legalMove = chess.move(moveObj);\r\n    if (legalMove) {\r\n      console.log('Move successful:', chess.fen());\r\n      // Save position before the move to history\r\n      moveHistory.push({\r\n        fen: legalMove.before,\r\n        move: legalMove\r\n      });\r\n      // Clear redo stack after a new move\r\n      redoStack.length = 0;\r\n      updateGame();\r\n    } else {\r\n      console.error('Move failed:', moveObj);\r\n    }\r\n  } catch (error) {\r\n    console.error('Error during move:', error.message);\r\n  }\r\n}\r\n\r\n// Add undo function\r\nexport function undo() {\r\n  if (moveHistory.length === 0) {\r\n    console.log('No moves to undo');\r\n    return;\r\n  }\r\n\r\n  const lastPosition = moveHistory.pop();\r\n  redoStack.push({\r\n    fen: chess.fen(),\r\n    move: chess.history({ verbose: true }).pop()\r\n  });\r\n  \r\n  // Load the previous position\r\n  chess.reset();\r\n  moveHistory.forEach(({ move }) => {\r\n    chess.move(move);\r\n  });\r\n  console.log('Move undone, new state:', chess.fen());\r\n  updateGame();\r\n}\r\n\r\n// Add redo function\r\nexport function redo() {\r\n  if (redoStack.length === 0) {\r\n    console.log('No moves to redo');\r\n    return;\r\n  }\r\n\r\n  const nextPosition = redoStack.pop();\r\n  moveHistory.push({\r\n    fen: chess.fen(),\r\n    move: nextPosition.move\r\n  });\r\n  \r\n  // Replay the move that was undone\r\n  const { from, to, promotion } = nextPosition.move;\r\n  chess.move({ from, to, promotion });\r\n  console.log('Move redone, new state:', chess.fen());\r\n  updateGame();\r\n}\r\n\r\n// Update the updateGame function to properly display castling notation\r\nfunction updateGame(pendingPromotion = null) {\r\n  const isGameOver = chess.isGameOver();\r\n  \r\n  // Get standard notation history\r\n  const standardNotation = chess.history();\r\n  \r\n  // Get detailed move history with piece information\r\n  const detailedHistory = chess.history({ verbose: true });\r\n  \r\n  // Create enhanced notation with piece type and castling info\r\n  const enhancedNotation = standardNotation.map((move, index) => {\r\n    const detailedMove = detailedHistory[index];\r\n    if (!detailedMove) return move;\r\n    \r\n    // Special handling for castling\r\n    if (move === 'O-O') {\r\n      return 'King Castles Kingside';\r\n    } else if (move === 'O-O-O') {\r\n      return 'King Castles Queenside';\r\n    }\r\n    \r\n    // Map piece codes to readable names\r\n    const pieceNames = {\r\n      'p': 'Pawn',\r\n      'n': 'Knight',\r\n      'b': 'Bishop',\r\n      'r': 'Rook',\r\n      'q': 'Queen',\r\n      'k': 'King'\r\n    };\r\n    \r\n    const pieceName = pieceNames[detailedMove.piece] || 'Unknown';\r\n    \r\n    // Check if capture happened\r\n    let moveText = move;\r\n    if (detailedMove.captured) {\r\n      const capturedPiece = pieceNames[detailedMove.captured] || 'piece';\r\n      moveText += ` (captures ${capturedPiece})`;\r\n    }\r\n    \r\n    // Check if it's a check or checkmate\r\n    if (move.includes('+')) {\r\n      moveText = moveText.replace('+', '') + ' (check)';\r\n    } else if (move.includes('#')) {\r\n      moveText = moveText.replace('#', '') + ' (checkmate)';\r\n    }\r\n    \r\n    return `${pieceName} ${moveText}`;\r\n  });\r\n  \r\n  const newGame = {\r\n    board: chess.board(),\r\n    pendingPromotion,\r\n    isGameOver,\r\n    turn: chess.turn(),\r\n    result: isGameOver ? getGameResult() : null,\r\n    canUndo: moveHistory.length > 0,\r\n    canRedo: redoStack.length > 0, \r\n    moveNotation: enhancedNotation\r\n  };\r\n\r\n  localStorage.setItem('savedGame', chess.fen());\r\n  localStorage.setItem('moveHistory', JSON.stringify(moveHistory));\r\n  gameSubject.next(newGame);\r\n}\r\n\r\nfunction getGameResult() {\r\n  if (chess.isCheckmate()) {\r\n    const winner = chess.turn() === 'w' ? 'BLACK' : 'WHITE';\r\n    return `CHECKMATE - WINNER - ${winner}`;\r\n  } else if (chess.isDraw()) {\r\n    if (chess.isStalemate()) return 'DRAW - STALEMATE';\r\n    if (chess.isThreefoldRepetition()) return 'DRAW - REPETITION';\r\n    if (chess.isInsufficientMaterial()) return 'DRAW - INSUFFICIENT MATERIAL';\r\n    return 'DRAW - 50 MOVE RULE';\r\n  }\r\n  return 'UNKNOWN REASON';\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}