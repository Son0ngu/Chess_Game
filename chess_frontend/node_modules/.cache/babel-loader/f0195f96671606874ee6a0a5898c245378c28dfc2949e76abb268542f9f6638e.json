{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { useAuth } from '../context/AuthContext';\nimport { socket } from '../services/socket';\n\n/**\n * Custom hook to manage chess game state and socket communication\n * @param {string} gameId - The ID of the current game\n * @returns {Object} Chess game state and methods\n */\nconst useChess = gameId => {\n  _s();\n  const {\n    user\n  } = useAuth();\n\n  // Game state\n  const [board, setBoard] = useState(initialBoard());\n  const [position, setPosition] = useState(null);\n  const [moves, setMoves] = useState([]);\n  const [currentTurn, setCurrentTurn] = useState('white');\n  const [playerColor, setPlayerColor] = useState(null);\n  const [possibleMoves, setPossibleMoves] = useState({});\n  const [selectedPiece, setSelectedPiece] = useState(null);\n  const [pastPositions, setPastPositions] = useState([]);\n  const [futurePositions, setFuturePositions] = useState([]);\n  const [inCheck, setInCheck] = useState(false);\n  const [gameStatus, setGameStatus] = useState({\n    isGameOver: false,\n    result: null\n  });\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [undoStack, setUndoStack] = useState([]);\n\n  // Initialize game when component mounts\n  useEffect(() => {\n    if (!gameId) return;\n\n    // Join the game\n    socket.emit('game:join', {\n      gameId\n    });\n\n    // Handle initial game data\n    const handleGameData = data => {\n      if (!data) return;\n      setBoard(data.board || initialBoard());\n      setPosition(data.position || null);\n      setMoves(data.moves || []);\n      setCurrentTurn(data.currentTurn || 'white');\n\n      // Set player color based on the player's user ID\n      if (data.players && Array.isArray(data.players) && user) {\n        const playerData = data.players.find(p => p && p.id === user.id);\n        setPlayerColor((playerData === null || playerData === void 0 ? void 0 : playerData.color) || 'white');\n      }\n\n      // Update game status\n      setInCheck(data.inCheck || false);\n      setPossibleMoves(data.legalMoves || {});\n      if (data.gameOver) {\n        setGameStatus({\n          isGameOver: true,\n          result: data.result\n        });\n      }\n    };\n\n    // Listen for game updates\n    socket.on('game:update', data => {\n      if (!data) return;\n      console.log(\"Game update received:\", data.board, data.position);\n      setBoard(data.board || initialBoard());\n      setPosition(data.position || null);\n      setCurrentTurn(data.currentTurn || 'white');\n      setInCheck(data.inCheck || false);\n      setPossibleMoves(data.legalMoves || {});\n      if (data.lastMove) {\n        setMoves(prevMoves => [...prevMoves, data.lastMove]);\n      } else if (data.history) {\n        setMoves(data.history); // fallback khi undo hoặc khi join game\n      }\n      if (data.gameOver) {\n        setGameStatus({\n          isGameOver: true,\n          result: data.result\n        });\n      }\n\n      // If this update is from an undo operation, update our stacks\n      if (data.isUndoOperation && moves.length > 0) {\n        // Get the last move from our history\n        const lastMove = moves[moves.length - 1];\n\n        // Update our stacks\n        setMoveHistory(prevHistory => prevHistory.slice(0, -1));\n        setUndoStack(prevStack => [...prevStack, lastMove]);\n      }\n\n      // If this update is from a redo operation, update our stacks\n      if (data.isRedoOperation && undoStack.length > 0) {\n        // Get the move we just redid\n        const redoneMove = undoStack[undoStack.length - 1];\n\n        // Update our stacks\n        setUndoStack(prevStack => prevStack.slice(0, -1));\n        setMoveHistory(prevHistory => [...prevHistory, redoneMove]);\n      }\n    });\n\n    // Listen for game data when joining\n    socket.on('game:data', handleGameData);\n\n    // Listen for move validation failures\n    socket.on('game:moveRejected', error => {\n      console.error('Move rejected:', error);\n      // Reset any UI state needed after failed move\n    });\n\n    // Cleanup on unmount\n    return () => {\n      socket.off('game:update');\n      socket.off('game:data');\n      socket.off('game:moveRejected');\n      socket.off('game:undoDeclined');\n      socket.off('game:undoConfirmed');\n      socket.emit('game:leave', {\n        gameId\n      });\n    };\n  }, [gameId, user]);\n\n  // Handle undo declined event\n  useEffect(() => {\n    const handleUndoDeclined = data => {\n      if (!data) return;\n      alert(`${data.by || 'Opponent'} has declined the undo request.`);\n    };\n    socket.on('game:undoDeclined', handleUndoDeclined);\n    return () => {\n      socket.off('game:undoDeclined', handleUndoDeclined);\n    };\n  }, []);\n\n  // Handle undo confirmed event\n  useEffect(() => {\n    const handleUndoConfirmed = data => {\n      if (!data || !user) return;\n      const username = user.username || 'You';\n\n      // If we're the requester, ignore this event\n      if (data.by === username) return;\n      const accept = window.confirm(`${data.by || 'Opponent'} wants to undo the last move. Do you agree?`);\n      socket.emit('game:undoResponse', {\n        gameId,\n        accepted: accept\n      });\n    };\n    socket.on('game:undoConfirmed', handleUndoConfirmed);\n    return () => {\n      socket.off('game:undoConfirmed', handleUndoConfirmed);\n    };\n  }, [gameId, user]);\n\n  // Add event listener for undo request response\n  useEffect(() => {\n    socket.on('game:undoResponse', data => {\n      if (data.accepted) {\n        // If opponent accepts, perform the actual undo\n        socket.emit('game:undo', {\n          gameId\n        });\n      } else {\n        alert('Opponent declined your undo request');\n      }\n    });\n    return () => {\n      socket.off('game:undoResponse');\n    };\n  }, [gameId]);\n\n  // Add event listeners in useEffect for undo/redo events with the new names\n  useEffect(() => {\n    // Listen for undo requests from opponent\n    socket.on('confirm_undo_request', data => {\n      const requesterUsername = data.requesterUsername || 'Opponent';\n      const accept = window.confirm(`${requesterUsername} wants to undo the last move. Do you agree?`);\n      if (accept) {\n        socket.emit('accept_undo', {\n          gameId\n        });\n      } else {\n        socket.emit('reject_undo', {\n          gameId\n        });\n      }\n    });\n\n    // Listen for undo responses\n    socket.on('undo_accepted', () => {\n      console.log('Undo request was accepted');\n      // No need to do anything - server will broadcast the updated state\n    });\n    socket.on('undo_rejected', data => {\n      alert(`${data.by || 'Opponent'} declined your undo request`);\n    });\n    return () => {\n      socket.off('confirm_undo_request');\n      socket.off('undo_accepted');\n      socket.off('undo_rejected');\n    };\n  }, [gameId]);\n\n  // Handle piece selection and move highlighting\n  const selectPiece = useCallback((piece, position) => {\n    // Only allow selection of the player's own pieces during their turn\n    if (piece && piece.color === playerColor && currentTurn === playerColor) {\n      setSelectedPiece({\n        piece,\n        position\n      });\n      // Highlight possible moves for this piece\n    } else {\n      setSelectedPiece(null);\n    }\n  }, [playerColor, currentTurn]);\n\n  // Make a move\n  const makeMove = useCallback((from, to) => {\n    if (gameStatus.isGameOver || currentTurn !== playerColor) {\n      return false;\n    }\n    setPastPositions(prev => [...prev, position]);\n    setFuturePositions([]);\n\n    // Send move to server\n    socket.emit('game:move', {\n      gameId,\n      from,\n      to\n    });\n    return true;\n  }, [gameId, currentTurn, playerColor, gameStatus.isGameOver, position]);\n\n  // Update the undo function to use the new event name\n  const handleUndoRequest = useCallback(() => {\n    if (!gameId || gameStatus.isGameOver || currentTurn !== playerColor) {\n      return false;\n    }\n\n    // Request an undo using the new event name\n    socket.emit('request_undo', {\n      gameId\n    });\n    console.log('Undo requested for game:', gameId);\n    return true;\n  }, [gameId, currentTurn, playerColor, gameStatus.isGameOver]);\n\n  // Update the redo function to use the new event name\n  const handleRedoRequest = useCallback(() => {\n    if (!gameId || gameStatus.isGameOver || !undoStack || undoStack.length === 0) {\n      return false;\n    }\n\n    // Request a redo using the new event name\n    socket.emit('request_redo', {\n      gameId\n    });\n    console.log('Redo requested for game:', gameId);\n    return true;\n  }, [gameId, gameStatus.isGameOver, undoStack]);\n\n  // Reset game\n  const reset = useCallback(() => {\n    socket.emit('game:reset', {\n      gameId\n    });\n  }, [gameId]);\n  return {\n    board,\n    position,\n    currentTurn,\n    playerColor,\n    moves,\n    inCheck,\n    possibleMoves,\n    selectedPiece,\n    gameStatus,\n    moveHistory,\n    undoStack,\n    selectPiece,\n    makeMove,\n    undo: handleUndoRequest,\n    redo: handleRedoRequest,\n    reset\n  };\n};\n\n// Helper function to create initial empty board\n_s(useChess, \"RSkQo/G0KO1yrSyQ0sc1ui2IXgk=\", false, function () {\n  return [useAuth];\n});\nfunction initialBoard() {\n  // Create 8x8 empty board representation\n  // This could be replaced with FEN parsing if you use chess.js or another library\n  return Array(8).fill().map(() => Array(8).fill(null));\n}\nexport default useChess;","map":{"version":3,"names":["useState","useEffect","useCallback","useAuth","socket","useChess","gameId","_s","user","board","setBoard","initialBoard","position","setPosition","moves","setMoves","currentTurn","setCurrentTurn","playerColor","setPlayerColor","possibleMoves","setPossibleMoves","selectedPiece","setSelectedPiece","pastPositions","setPastPositions","futurePositions","setFuturePositions","inCheck","setInCheck","gameStatus","setGameStatus","isGameOver","result","moveHistory","setMoveHistory","undoStack","setUndoStack","emit","handleGameData","data","players","Array","isArray","playerData","find","p","id","color","legalMoves","gameOver","on","console","log","lastMove","prevMoves","history","isUndoOperation","length","prevHistory","slice","prevStack","isRedoOperation","redoneMove","error","off","handleUndoDeclined","alert","by","handleUndoConfirmed","username","accept","window","confirm","accepted","requesterUsername","selectPiece","piece","makeMove","from","to","prev","handleUndoRequest","handleRedoRequest","reset","undo","redo","fill","map"],"sources":["/home/sonbx/Documents/Project/Chess_Game/chess_frontend/src/hooks/useChess.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { useAuth } from '../context/AuthContext';\nimport { socket } from '../services/socket';\n\n/**\n * Custom hook to manage chess game state and socket communication\n * @param {string} gameId - The ID of the current game\n * @returns {Object} Chess game state and methods\n */\nconst useChess = (gameId) => {\n  const { user } = useAuth();\n  \n  // Game state\n  const [board, setBoard] = useState(initialBoard());\n  const [position, setPosition] = useState(null);\n  const [moves, setMoves] = useState([]);\n  const [currentTurn, setCurrentTurn] = useState('white');\n  const [playerColor, setPlayerColor] = useState(null);\n  const [possibleMoves, setPossibleMoves] = useState({});\n  const [selectedPiece, setSelectedPiece] = useState(null);\n  const [pastPositions, setPastPositions] = useState([]);\n  const [futurePositions, setFuturePositions] = useState([]);\n  const [inCheck, setInCheck] = useState(false);\n  const [gameStatus, setGameStatus] = useState({\n    isGameOver: false,\n    result: null\n  });\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [undoStack, setUndoStack] = useState([]);\n  \n  // Initialize game when component mounts\n  useEffect(() => {\n    if (!gameId) return;\n\n    // Join the game\n    socket.emit('game:join', { gameId });\n    \n    // Handle initial game data\n    const handleGameData = (data) => {\n      if (!data) return;\n      \n      setBoard(data.board || initialBoard());\n      setPosition(data.position || null);\n      setMoves(data.moves || []);\n      setCurrentTurn(data.currentTurn || 'white');\n      \n      // Set player color based on the player's user ID\n      if (data.players && Array.isArray(data.players) && user) {\n        const playerData = data.players.find(p => p && p.id === user.id);\n        setPlayerColor(playerData?.color || 'white');\n      }\n      \n      // Update game status\n      setInCheck(data.inCheck || false);\n      setPossibleMoves(data.legalMoves || {});\n\n      if (data.gameOver) {\n        setGameStatus({\n          isGameOver: true,\n          result: data.result\n        });\n      }\n    };\n\n    // Listen for game updates\n    socket.on('game:update', (data) => {\n      if (!data) return;\n      \n      console.log(\"Game update received:\", data.board, data.position);\n      setBoard(data.board || initialBoard());\n      setPosition(data.position || null);\n      setCurrentTurn(data.currentTurn || 'white');\n      setInCheck(data.inCheck || false);\n      setPossibleMoves(data.legalMoves || {});\n\n      if (data.lastMove) {\n        setMoves(prevMoves => [...prevMoves, data.lastMove]);\n      } else if (data.history) {\n        setMoves(data.history); // fallback khi undo hoặc khi join game\n      }\n      \n      if (data.gameOver) {\n        setGameStatus({\n          isGameOver: true,\n          result: data.result\n        });\n      }\n\n      // If this update is from an undo operation, update our stacks\n      if (data.isUndoOperation && moves.length > 0) {\n        // Get the last move from our history\n        const lastMove = moves[moves.length - 1];\n        \n        // Update our stacks\n        setMoveHistory(prevHistory => prevHistory.slice(0, -1));\n        setUndoStack(prevStack => [...prevStack, lastMove]);\n      }\n      \n      // If this update is from a redo operation, update our stacks\n      if (data.isRedoOperation && undoStack.length > 0) {\n        // Get the move we just redid\n        const redoneMove = undoStack[undoStack.length - 1];\n        \n        // Update our stacks\n        setUndoStack(prevStack => prevStack.slice(0, -1));\n        setMoveHistory(prevHistory => [...prevHistory, redoneMove]);\n      }\n    });\n    \n    // Listen for game data when joining\n    socket.on('game:data', handleGameData);\n    \n    // Listen for move validation failures\n    socket.on('game:moveRejected', (error) => {\n      console.error('Move rejected:', error);\n      // Reset any UI state needed after failed move\n    });\n    \n    // Cleanup on unmount\n    return () => {\n      socket.off('game:update');\n      socket.off('game:data');\n      socket.off('game:moveRejected');\n      socket.off('game:undoDeclined');\n      socket.off('game:undoConfirmed');\n      socket.emit('game:leave', { gameId });\n    };\n  }, [gameId, user]);\n\n  // Handle undo declined event\n  useEffect(() => {\n    const handleUndoDeclined = (data) => {\n      if (!data) return;\n      alert(`${data.by || 'Opponent'} has declined the undo request.`);\n    };\n    \n    socket.on('game:undoDeclined', handleUndoDeclined);\n    \n    return () => {\n      socket.off('game:undoDeclined', handleUndoDeclined);\n    };\n  }, []);\n  \n  // Handle undo confirmed event\n  useEffect(() => {\n    const handleUndoConfirmed = (data) => {\n      if (!data || !user) return;\n      \n      const username = user.username || 'You';\n      \n      // If we're the requester, ignore this event\n      if (data.by === username) return;\n      \n      const accept = window.confirm(`${data.by || 'Opponent'} wants to undo the last move. Do you agree?`);\n      socket.emit('game:undoResponse', {\n        gameId,\n        accepted: accept\n      });\n    };\n    \n    socket.on('game:undoConfirmed', handleUndoConfirmed);\n    \n    return () => {\n      socket.off('game:undoConfirmed', handleUndoConfirmed);\n    };\n  }, [gameId, user]);\n\n  // Add event listener for undo request response\n  useEffect(() => {\n    socket.on('game:undoResponse', (data) => {\n      if (data.accepted) {\n        // If opponent accepts, perform the actual undo\n        socket.emit('game:undo', { gameId });\n      } else {\n        alert('Opponent declined your undo request');\n      }\n    });\n    \n    return () => {\n      socket.off('game:undoResponse');\n    };\n  }, [gameId]);\n\n  // Add event listeners in useEffect for undo/redo events with the new names\n  useEffect(() => {\n    // Listen for undo requests from opponent\n    socket.on('confirm_undo_request', (data) => {\n      const requesterUsername = data.requesterUsername || 'Opponent';\n      const accept = window.confirm(`${requesterUsername} wants to undo the last move. Do you agree?`);\n      \n      if (accept) {\n        socket.emit('accept_undo', { gameId });\n      } else {\n        socket.emit('reject_undo', { gameId });\n      }\n    });\n    \n    // Listen for undo responses\n    socket.on('undo_accepted', () => {\n      console.log('Undo request was accepted');\n      // No need to do anything - server will broadcast the updated state\n    });\n    \n    socket.on('undo_rejected', (data) => {\n      alert(`${data.by || 'Opponent'} declined your undo request`);\n    });\n    \n    return () => {\n      socket.off('confirm_undo_request');\n      socket.off('undo_accepted');\n      socket.off('undo_rejected');\n    };\n  }, [gameId]);\n  \n  // Handle piece selection and move highlighting\n  const selectPiece = useCallback((piece, position) => {\n    // Only allow selection of the player's own pieces during their turn\n    if (piece && piece.color === playerColor && currentTurn === playerColor) {\n      setSelectedPiece({ piece, position });\n      // Highlight possible moves for this piece\n    } else {\n      setSelectedPiece(null);\n    }\n  }, [playerColor, currentTurn]);\n  \n  // Make a move\n  const makeMove = useCallback((from, to) => {\n    if (gameStatus.isGameOver || currentTurn !== playerColor) {\n      return false;\n    }\n\n    setPastPositions(prev => [...prev, position]);\n    setFuturePositions([]);\n    \n    // Send move to server\n    socket.emit('game:move', {\n      gameId,\n      from,\n      to\n    });\n    \n    return true;\n  }, [gameId, currentTurn, playerColor, gameStatus.isGameOver, position]);\n  \n  // Update the undo function to use the new event name\n  const handleUndoRequest = useCallback(() => {\n    if (!gameId || gameStatus.isGameOver || currentTurn !== playerColor) {\n      return false;\n    }\n    \n    // Request an undo using the new event name\n    socket.emit('request_undo', { gameId });\n    console.log('Undo requested for game:', gameId);\n    \n    return true;\n  }, [gameId, currentTurn, playerColor, gameStatus.isGameOver]);\n\n  // Update the redo function to use the new event name\n  const handleRedoRequest = useCallback(() => {\n    if (!gameId || gameStatus.isGameOver || !undoStack || undoStack.length === 0) {\n      return false;\n    }\n    \n    // Request a redo using the new event name\n    socket.emit('request_redo', { gameId });\n    console.log('Redo requested for game:', gameId);\n    \n    return true;\n  }, [gameId, gameStatus.isGameOver, undoStack]);\n  \n  // Reset game\n  const reset = useCallback(() => {\n    socket.emit('game:reset', { gameId });\n  }, [gameId]);\n  \n  return {\n    board,\n    position,\n    currentTurn,\n    playerColor,\n    moves,\n    inCheck,\n    possibleMoves,\n    selectedPiece,\n    gameStatus,\n    moveHistory,\n    undoStack,\n    selectPiece,\n    makeMove,\n    undo: handleUndoRequest,\n    redo: handleRedoRequest,\n    reset\n  };\n};\n\n// Helper function to create initial empty board\nfunction initialBoard() {\n  // Create 8x8 empty board representation\n  // This could be replaced with FEN parsing if you use chess.js or another library\n  return Array(8).fill().map(() => Array(8).fill(null));\n}\n\nexport default useChess;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}